<!doctype html><html lang=en><head><title>Extending ServiceMix management features using Spring - Part 3 · Ioannis Canellos - My Blog
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Ioannis Canellos"><meta name=description content="In the previous post Extend ServiceMix Management features using Spring – Part 2 I demonstrated how to use spring to gain control over endpoint lifecycle and configuration via jmx. You might wonder till now “what happens to those custom changes if I have to redeploy the assembly, restart servicemix or even worse restart the server?”. The short answer is that these changes are lost. The long answer is in this blog post, which explains how to persist those changes and how to make the endpoint reload them each time it starts."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Extending ServiceMix management features using Spring - Part 3"><meta name=twitter:description content="In the previous post Extend ServiceMix Management features using Spring – Part 2 I demonstrated how to use spring to gain control over endpoint lifecycle and configuration via jmx. You might wonder till now “what happens to those custom changes if I have to redeploy the assembly, restart servicemix or even worse restart the server?”. The short answer is that these changes are lost. The long answer is in this blog post, which explains how to persist those changes and how to make the endpoint reload them each time it starts."><meta property="og:title" content="Extending ServiceMix management features using Spring - Part 3"><meta property="og:description" content="In the previous post Extend ServiceMix Management features using Spring – Part 2 I demonstrated how to use spring to gain control over endpoint lifecycle and configuration via jmx. You might wonder till now “what happens to those custom changes if I have to redeploy the assembly, restart servicemix or even worse restart the server?”. The short answer is that these changes are lost. The long answer is in this blog post, which explains how to persist those changes and how to make the endpoint reload them each time it starts."><meta property="og:type" content="article"><meta property="og:url" content="https://iocanel.github.io/2010/05/extending-servicemix-management-features-using-spring-part-3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2010-05-15T00:00:00+03:00"><meta property="article:modified_time" content="2010-05-15T00:00:00+03:00"><link rel=canonical href=https://iocanel.github.io/2010/05/extending-servicemix-management-features-using-spring-part-3/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.c4d7e93a158eda5a65b3df343745d2092a0a1e2170feeec909b8a89443903c6a.css integrity="sha256-xNfpOhWO2lpls980N0XSCSoKHiFw/u7JCbiolEOQPGo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.78b5fe3864945faf5207fb8fe3ab2320d49c3365def0e88ac1df0ddadc54a03c.css integrity="sha256-eLX+OGSUX69SB/uP46sjINScM2Xe8OiKwd8N2txUoDw=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.123.6"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Ioannis Canellos - My Blog
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>blog</a></li><li class=navigation-item><a class=navigation-link href=/about/>about</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://iocanel.github.io/2010/05/extending-servicemix-management-features-using-spring-part-3/>Extending ServiceMix management features using Spring - Part 3</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2010-05-15T00:00:00+03:00>May 15, 2010
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
5-minute read</span></div></div></header><div><p>In the previous post <a href=http://iocanel.com/2010/05/extend-servicemix-management-features-using-spring-part-2/>Extend ServiceMix Management features using Spring – Part 2</a> I demonstrated how to use spring to gain control over endpoint lifecycle and configuration via jmx. You might wonder till now “what happens to those custom changes if I have to redeploy the assembly, restart servicemix or even worse restart the server?”. The short answer is that these changes are lost. The long answer is in this blog post, which explains how to persist those changes and how to make the endpoint reload them each time it starts.</p><h2 id=part-iii-modifying-persisting-and-loading-custom-configuration-automatically>Part III : Modifying, Persisting and Loading Custom Configuration Automatically
<a class=heading-link href=#part-iii-modifying-persisting-and-loading-custom-configuration-automatically><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In order to persist and auto load custom configuration upon endpoint start-up all we need are the following.</p><h3 id=for-persisting>For persisting
<a class=heading-link href=#for-persisting><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>A way to serialize the configuration in xml (jaxb2).</li><li>A way to persist the configuration (jpa/hibernate).</li></ul><h3 id=for-auto-loading>For auto loading
<a class=heading-link href=#for-auto-loading><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>A way to intercept endpoint start and activate methods (spring aop).</li><li>A way to apply that configuration to the endpoint (beanutils).</li></ul><p>The basic idea is that for each endpoint, the custom configuration can be serialized to xml and persisted and with the use of aop interceptors reloaded to the endpoint each time it starts up.</p><h2 id=step-1-configuring-persistence>Step 1: Configuring persistence
<a class=heading-link href=#step-1-configuring-persistence><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For persisting configuration I am going to use JPA/Hibernate and MySQL.
I want to keep things as simple as possible, so I will create a table that will only contains 2 fields</p><ul><li><strong><strong>ID</strong></strong>: the id of the endpoint which will be the primary key</li><li><strong><strong>CONFIGURATION</strong></strong>: A text field that will hold the configuration in xml format</li></ul><p>The endpoint id can be retrieved by calling endpoint.getKey(). The configuration is the XML representation of the configuration (more details later).</p><p>The persistence unit, the entity and the data access object are things that we want to be reusable so they better be in a separate jar. I will call this management-support.</p><p>Let’s start creating the new jar by adding the entity.</p><p>Now we can create the persistence unit. Note that in this example I am adding all the database connection information inside persistence.xml leaving pooling to hibernate. It would be better if I created a datasource, but for the shake of simplicity I will not.</p><p>Now its time to create a very simple dao for the EndpointConfiguration entity.</p><h2 id=step-2-configuring-configuration-serialization>Step 2: Configuring configuration serialization
<a class=heading-link href=#step-2-configuring-configuration-serialization><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For each endpoint type that we want its configuration to be serialized and persistence I am going to create a pojo that contains all the properties that are managed. The pojo will be annotated with Jaxb annotations so that we can easily serialize it to xml. Before serialization takes place the pojo needs to be set the values of the current configuration. For this purpose I am going to use BeanUtils (spring beanutils). Now we can update our endpoint manager and add 2 methods (save & load of configuration) and the ConfigurationDao that was presented above.</p><p>The new endpoint manager will expose to the jmx the saveConfiguration and loadConfiguration managed operation.</p><h2 id=step-3-configuring-endpoint-lifecycle-interception>Step 3: Configuring Endpoint lifecycle interception
<a class=heading-link href=#step-3-configuring-endpoint-lifecycle-interception><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In this section I will show how to intercept the lifecycle methods of the endpoint using spring-aop. Spring aop will be configured using cglib proxies. The goal is to intercept start and activate methods call the method load configuration on the endpoint manager and then proceed with the execution. So the interceptor needs to be aware of the endpoint that intercepts(determined by the pointcut definition) and the endpoint manager(will be injected to the bean that will play the role of the Aspect). So the interceptor will look like this</p><p>Note that we are intercepting both start and activate methods. This is because in some endpoints in order to refresh their configuration needs to be restarted while other need to be reactivated.</p><h2 id=step-4-putting-the-pieces-together>Step 4: Putting the pieces together
<a class=heading-link href=#step-4-putting-the-pieces-together><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Now, its time to put all the pieces together. I am going to create a new jar the management support and add to it a generic endpoint manager(the base class for all entpoint managers), the endpoint configuration entity, the configuration dao and the persistance unit. The example project(wsdl-first) will be modified so that the HttpEndpointManager extends the generic endpoint manager and the http-su xbean.xml configures persistence and aop as explained above.</p><p>The generic EndpointManager
The POJO that represents HttpEndpoint configuration
The updated HttpEndpointManager</p><p>And finally the xbean.xml for the http service unit
The final configuration might seem a bit bloated. It can become a lot tidier by using xbean features, however this goes far beyound the scope of this post.</p><h2 id=preparing-the-container>Preparing the container
<a class=heading-link href=#preparing-the-container><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For this example to run we need to add a few jars to servicemix</p><ul><li>hibernate-entitymanager</li><li>hibernate-annotations</li><li>aspectjrt</li><li>spring-orm</li><li>the dependencies of the above</li></ul><p>You can download the complete example here which will contains all the dependencies under wsdl-first/lib/optional.</p><h2 id=final-words>Final words
<a class=heading-link href=#final-words><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>I hope that you find it useful. Personally, I’ve been using it for quite some time now and I am very happy with it. Using this you can even alter the xslt of an xslt-endpoint using the jmx console without having to recompile, redeploy or restart your assmebly.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2024
Ioannis Canellos
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script></body></html>